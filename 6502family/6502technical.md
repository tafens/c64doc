# 6502 technical

This document tries to explain some of the more intricate details in how the 6502 handles some of its functions. In particular, functions that are often implemented with various degrees of correctness or are simply skipped altogether.



## How ADC and SBC works in decimal mode on the 6502

The adder in the 6502 ALU actually consists of two 4-bit (nibble) half-adders with a half-carry in-between instead of one 8-bit full adder. The main carry flag goes into the low nibble adder and comes out of the high nibble adder. The result is the low and high nibbles together, from which the other flags N, V, and Z are then also calculated. Subtraction is achieved by simply inverting the second operand using 1’s complement and thereby treating the carry flag as a borrow instead.

When two numbers are being added they are broken down to their high and low nibbles that are handled separately by the half-adders. The main carry flag goes into the low nibble adder, and its half-carry is then set if the result of the add, including the main carry, is larger than 4 bits. The half-carry from the low nibble adder goes into the high nibble adder to add an additional one to the high nibble addition if set. The half-carry from the high nibble adder then becomes the carry out for the full 8-bit add. The 8-bit result is combined from the results of the half-adders and the other flags are set according to it. 

In binary mode, this is really no different from a full 8-bit adder, but when it comes to how the 6502 handles add/subtract of binary coded decimal numbers, this setup becomes important.

Instead of specific decimal add/subtract instructions or specific decimal add/subtract adjust instructions as other processors of the time may have, the 6502 has a special decimal mode-flag in the status register which affects the operation of the normally binary ADC/SBC instructions. Moreover, adding/subtracting BCD-numbers in decimal mode is handled with no extra overhead at all. This is thanks to a very clever technique involving on-the-fly decimal carry calculation and decimal adjust that was patented by MOS in the day, though the patents have since expired. As clever as it was, it wasn’t without drawbacks however; only the carry flag is guaranteed to be set correctly in decimal mode, the other flags are undocumented (and although their behaviour is still fully predictable, their meaning are somewhat complicated as seen to the end result).

When an addition is executed in decimal mode, the DAA (decimal add adjust) line is activated. This activates a special decimal carry calculation for each half-adder which instead  sets the carry if the result is larger than 9. It also activates the decimal correction logic for each adder which acts on the result nibble as a final step that adds a further 6 to it if the (now decimal) half-carry from its adder was set. This correction is performed by a very specific set of logic gates that does not affects the other nibble, does not affect any flags, and just wraps around if result is too large.

Subtraction is similar, but different. The adding logic is still used, but one of the operands are inverted before the addition (one's complement, this happens in both binary and decimal modes). When a subtraction is executed in decimal mode, the DSA (decimal subtract adjust) line is activated instead. Contrary to DAA, this does not activate the decimal carry calculation for any adder, but it does activate the decimal correction logic. The decimal correction behaves differently though, now instead subtracting 6 from the result nibble if the binary carry from its adder was not set.

The fact that decimal adjust is done as the final step is key to the other flags besides carry being undocumented in decimal mode, because they are calculated on the result before decimal adjust, and may therefore be incorrect with regard to the final result. The flags are affected by the decimal mode, but only to the extent that the half-carry will be a decimal carry if adding in decimal mode, thereby affecting the addition itself.

For example, adding $76 and $89 with carry set in decimal mode results in $00 before decimal adjust; low nibble = $6+$9+$1 = $10, which is $0 with the decimal half-carry set; high nibble = $7+$8+$1 = $10, which is also $0 with decimal half-carry set. So result before decimal adjust is $00, negative flag clear, overflow flag clear, zero flag set, carry flag set. Decimal adjust then adds 6 to both the low and high nibbles respectively because their decimal carries were both set, giving a final result of $66 with the carry flag being set as 76+89+1=166, but with the zero flag also oddly being set (but predictably so, as the intermediate result before decimal adjust actually was zero).

This quirk in the behaviour of the flags is very likely due to design, time, and/or physical constraints during development, and the later 65C02 indeed fixes this at the expense of using one more cycle to set the NVZ-flags correctly according to the final, decimal adjusted, result.



## How interrupts work on the 6502

The 6502 has two pins dedicated to interrupts, the IRQ (Interrupt ReQuest) and NMI (Non-Maskable Interrupt) pins, that are both active low. For each pin there is an interrupt detector unit that the processor polls at certain times. If an interrupt detector is active at the time of polling, the processor will commit to performing the interrupt sequence immediately after the current instruction ends instead of fetching and executing the next regular instruction. It does this by setting its internal interrupt line high, and this what the B-flag in the status register actually reflects (albeit inverted, which is why the B-flag is clear when saved by an interrupt and set when saved by by PHP or a regular BRK).

The IRQ detector is activated by the IRQ pin being held low, but only if the I-flag (interrupt disable) of the status register is clear at the same time. The IRQ detector is only active for one cycle, but will be activated again the next cycle if the conditions for its activation are still in effect. The NMI detector is activated by a negative transition of the NMI pin (i.e. it transitions from high to low, thus requiring the pin to go back high before it can be activated again). Once activated, the NMI detector will remain active until an interrupt sequence has been executed. Both interrupt detectors are activated during the second half (phase 2) of the clock cycle if their respective conditions are met at that time.

The interrupt detectors are always polled on the cycle before the SYNC pin goes active. This is also true for instructions that have a variable number of cycles in their addressing mode (indexed addressing modes where the final address is crossing or not crossing a page boundary). There are however two exceptions; the BRK instruction, which does not poll interrupts at all, and the branch instructions, specifically the 3-cycle branch (when the branch is taken to the same page), which is the only time interrupts are not polled on the cycle before SYNC, instead polling happens one cycle earlier (in the same place as the 2-cycle branch). In addition, the 4-cycle branch instruction actually polls two times, both in the usual place on the cycle before SYNC, but also two cycles prior - again in the same place as the 2-cycle branch.

There are only four instructions (CLI, SEI, PHP, and RTI) that can affect the I-flag outside of the interrupt sequence (BRK being the interrupt sequence itself), and their specific timings in conjunction with interrupt detection and polling have an effect on when an interrupt is and is not taken. This may make interrupts around these instructions a bit counterintuitive at times.
CLI and SEI polls interrupts before detection can occur with the new value of the I-flag, therefore an interrupt cannot happen directly after CLI if the I flag was set before, however an interrupt can happen directly after SEI if the I flag was clear before. PLP polls interrupts the cycle before restoring the status register and thus the possibility of interrupts directly after this instruction depends only on the value of the I-flag before it was restored, and not the value that was restored. RTI polls interrupts the cycle after restoring the status register, and thus the possibility of interrupts directly after this instruction depends only on the value of the I-flag after it was restored, and not the value before it was restored. As for BRK, because it does not poll interrupts at all, an interrupt can never occur directly after it - but because of how it works internally, an interrupt can modify its behaviour if the detectors are triggered in certain cycles of its execution.

**BRK instruction modified by an IRQ interrupt:** Even if an IRQ detect during BRK technically affects the vector used, it will still be the same vector as BRK normally uses ($FFFE/$FFFF) and will have no practical effect. The B-flag will also remain set, so the IRQ is essentially lost. However, as long as IRQ is still asserted (and it normally is, until the interrupt handler code clears the interrupt source), it will be detected and handled as soon as the I-flag is cleared again.

**BRK instruction modified by an NMI interrupt:** If NMI is detected during any cycle before P is saved on the stack, the BRK instead jumps to the NMI vector but with the B flag still set. However, a short NMI pulse on either one or both of the two cycles where the cpu saves P on the stack and where it puts out the address of the vector low byte is ignored and the NMI is lost. However, if NMI is detected or still held low after that (which it normally is, until the interrupt handler code clears the interrupt source), the NMI will still occur after the first or second instruction in the BRK-handler depending on where exactly NMI was asserted and then detected/polled (i.e. NMI is handled normally).